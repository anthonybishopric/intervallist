{"version":3,"sources":["Intervals.js","Spotify.js","GeneratePlaylist.js","App.js","serviceWorker.js","index.js"],"names":["Intervals","props","createBarChart","bind","this","node","yValues","data","intervalData","map","interval","ftpPercent","intervalsToGraph","absoluteTimePosition","i","length","dims","x","y","durationSecs","width","push","artworkToGraph","playlistData","song","size","durationMs","dataMax","max","yScale","scaleLinear","domain","range","maxX","xScale","select","selectAll","enter","append","exit","remove","colorRange","unknown","attr","d","lower","raise","artwork","ref","height","Component","validTransitions","WARMING","TR_RISE_OVER_FTP","TR_RISE_SS","TR_FALL_SS","TR_FALL_UNDER_75","COOL","TR_END","SS_INTERVAL","VO2_INTERVAL","StateMachine","startState","intensities","curState","state","nextTransition","computeTransition","nextState","curPosition","curFtp","nextFtp","Spotify","accessToken","headers","axios","get","playlistId","trackIds","trackDataCallback","tracksToQuery","splice","encodeURIComponent","join","resp","GeneratePlaylist","stateMachine","getSongWithArtwork","match","params","playlist_id","ssBreak","ssInterval","vO2MaxInterval","vO2MaxBreak","anaerobicSprint","anaerobicSprintRecovery","workouts","sweetSpot","name","vO2Max","sprints","songData","selectedWorkout","spotify","localStorage","getItem","workout","setState","loadAllPlaylistTracks","then","updatePlaylistDataBase","items","item","track","id","loadAllTrackDetails","updateSongDataFeatures","playlistDataObj","forEach","songDataObj","audio_features","songs","Object","keys","itemKey","trackData","key","artists","moment","duration","duration_ms","humanize","danceability","energy","loudness","valence","tempo","playlist","computePlaylist","intensity","src","title","reduce","a","b","type","value","onChange","updateWorkout","disabled","window","innerWidth","className","computeIntervalIntensities","getWarmupSongs","getSSSongs","getVO2MaxSongs","console","log","oneMin","twoMin","thirtySec","usedSongs","previousIntensityRemainderMs","selectedIntensitySongs","candidateSongs","durationRemainingMs","keepGoing","inUse","songCandidate","pop","remainder","decompressionTime","playlistSongInfo","album","images","albumImages","url","artist","songFeaturesAsArray","sort","song1","song2","React","SpotifyComponent","handleLoginClick","spotifyAccessCode","playlists","spotifyError","location","href","spotifyBody","listItems","to","pathname","tracks","total","class","onClick","self","loadMyPlaylists","catch","error","SpotifyExchangeCodeForAccessToken","URLSearchParams","search","split","hash","hashComp","includes","replace","setItem","history","App","path","exact","component","Boolean","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","message"],"mappings":"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","file":"static/js/main.bd1370d9.chunk.js","sourcesContent":["import React, { Component } from 'react'\nimport './App.css'\nimport { scaleLinear } from 'd3-scale';\nimport { max } from 'd3-array';\nimport { select } from 'd3-selection';\nimport { easeLinear } from 'd3';\n\nexport class Intervals extends Component {\n    constructor(props) {\n        super(props)\n        this.createBarChart = this.createBarChart.bind(this)\n    }\n    componentDidMount() {\n        this.createBarChart()\n    }\n    componentDidUpdate() {\n        this.createBarChart()\n    }\n    createBarChart() {\n        const node = this.node\n\n        const intervalYOffset = 50; // gives space for artwork\n\n        let yValues = this.props.data.intervalData.map(interval => (\n            interval.ftpPercent\n        ));\n\n        let intervalsToGraph = []; // contains exact dimensions for graphing\n        var absoluteTimePosition = 0;\n        for (var i = 0; i < this.props.data.intervalData.length; i++) {\n            var dims = { x: absoluteTimePosition, y: yValues[i] };\n            absoluteTimePosition += this.props.data.intervalData[i].durationSecs;\n            dims.width = absoluteTimePosition - dims.x;\n            intervalsToGraph.push(dims);\n        }\n\n        let artworkToGraph = [];\n        if (this.props.playlistData) {\n            var absoluteTimePosition = 0;\n            for (let song of this.props.playlistData) {\n                artworkToGraph.push({x: absoluteTimePosition, y: this.props.size[1] - intervalYOffset, song: song})\n                absoluteTimePosition += song.durationMs / 1000;\n            }\n        }\n        \n        const dataMax = max([max(yValues), 200]); // 200 = % of FTP, not pixel size\n        const yScale = scaleLinear()\n            .domain([0, dataMax])\n            .range([0, this.props.size[1]]);\n\n        const maxX = intervalsToGraph[intervalsToGraph.length-1].x + intervalsToGraph[intervalsToGraph.length-1].width;\n        const xScale = scaleLinear()\n            .domain([0,  maxX])\n            .range([0, this.props.size[0]]);\n\n        select(node)\n            .selectAll('rect')\n            .data(yValues)\n            .enter()\n            .append('rect');\n\n        select(node)\n            .selectAll('rect')\n            .data(yValues)\n            .exit()\n            .remove();\n\n        select(node)\n            .selectAll('image')\n            .data(artworkToGraph)\n            .enter()\n            .append('image');\n\n        select(node)\n            .selectAll('image')\n            .data(artworkToGraph)\n            .exit()\n            .remove();\n\n        let colorRange = scaleLinear()\n            .domain([0, 200]) // 200 = % of FTP, not pixel size\n            .range([\"yellow\", \"red\"])\n            .unknown(\"#ccc\");\n\n        select(node)\n            .selectAll('rect')\n            .data(intervalsToGraph)\n            .attr('fill', (d, i) => colorRange(d.y))\n            .attr('x', (d, i) => xScale(d.x))\n            .attr('y', d => this.props.size[1] - yScale(d.y))\n            .attr('z', 10)\n            .attr('height', d => yScale(d.y))\n            .attr('width', (d) => xScale(d.width))\n            .lower();\n\n        select(node)\n            .selectAll('line')\n            .data([1])\n            .enter()\n            .append('line')\n            .attr('stroke', 'white')\n            .attr('stroke-dasharray', '5 2')\n            .attr('x1', xScale(0))\n            .attr('y1', this.props.size[1] - yScale(100))\n            .attr('x2', xScale(maxX))\n            .attr('y2', this.props.size[1] - yScale(100))\n            .raise();\n        \n        select(node)\n            .selectAll('path')\n            .data([1])\n\n        select(node)\n            .selectAll('image')\n            .data(artworkToGraph)\n            .append(\"image\")\n            .attr('x', (d) => xScale(d.x))\n            .attr('y', yScale(intervalYOffset))\n            .attr('width', 64)\n            .attr('height', 64)\n            .attr(\"xlink:href\", (d) => d.song.artwork);\n\n    }\n    render() {\n        return <svg ref={node => this.node = node}\n            width={this.props.size[0]} height={this.props.size[1]}>\n        </svg>\n    }\n}\nexport default Intervals\n\n// transitions\nconst TR_RISE_OVER_FTP       = 'TR_RISE_OVER_FTP';\nconst TR_RISE_SS             = 'TR_RISE_SS';\nconst TR_FALL_UNDER_75       = 'TR_FALL_UNDER_75';\nconst TR_FALL_UNDER_75_LT_1M = 'TR_FALL_UNDER_75_LT_1M'; // special case for intervals with breaks less than 1min\nconst TR_FALL_SS             = 'TR_FALL_SS';\nconst TR_END                 = 'TR_END';\nconst TR_STAY                = 'TR_STAY'; // no change\n\n// states\nexport const WARMING      = 'WARMING';\nexport const COOL         = 'COOL'; \nexport const SS_INTERVAL  = 'SS_INTERVAL';\nexport const VO2_INTERVAL = 'VO2_INTERVAL';\nexport const FINISH       = 'FINISH';\n\nconst validTransitions = {\n    WARMING: {\n        TR_RISE_OVER_FTP: WARMING,\n        TR_RISE_SS: WARMING,\n        TR_FALL_SS: WARMING,\n        TR_FALL_UNDER_75: COOL\n    },\n    COOL: {\n        TR_RISE_OVER_FTP: VO2_INTERVAL,\n        TR_RISE_SS: SS_INTERVAL,\n        TR_END: FINISH\n    },\n    SS_INTERVAL: {\n        TR_FALL_UNDER_75: COOL,\n        TR_RISE_OVER_FTP: VO2_INTERVAL,\n        TR_END: FINISH\n    },\n    VO2_INTERVAL: {\n        TR_FALL_SS: SS_INTERVAL,\n        TR_FALL_UNDER_75: COOL,\n        TR_END: FINISH\n    }\n}\n\nexport class StateMachine {\n    constructor() {\n        this.startState = WARMING;\n    }\n\n    /**\n     * @param {Array} the interval data as configured\n     * @returns {Array} an array of {duration, state} that can be used by the\n     * playlist generator to select songs\n     */\n    computeIntervalIntensities(intervalData) {\n        if (intervalData.length === 0) {\n            return [];\n        }\n        let intensities = [];\n        let curState = this.startState;\n        intensities.push({\n            state: this.startState, \n            durationSecs: intervalData[0].durationSecs\n        });\n\n        for (let i = 0; i < intervalData.length; i++) {\n            let nextTransition = this.computeTransition(intervalData, i);\n            let nextState = validTransitions[curState][nextTransition];\n            if (nextState === FINISH) {\n                intensities.push({\n                    state: FINISH,\n                    durationSecs: 0\n                });\n                break;\n            } else if (nextState === TR_STAY || !nextState || nextState === curState) {\n                // no transition\n                intensities[intensities.length -1].durationSecs+= intervalData[i+1].durationSecs;\n            } else {\n                // new state\n                intensities.push({\n                    state: nextState,\n                    durationSecs: intervalData[i+1].durationSecs\n                })\n                curState = nextState;\n            }\n        }\n        return intensities;\n    }\n\n    /**\n     * \n     * @param {Array} intervalData \n     * @param {Number} curPosition the interval we are switching from (curPos+1 is next)\n     */\n    computeTransition(intervalData, curPosition) {\n        if (curPosition === intervalData.length - 1) {\n            return TR_END;\n        }\n        const curFtp = intervalData[curPosition].ftpPercent;\n        const nextFtp = intervalData[curPosition+1].ftpPercent;\n\n        if (curFtp < 75 && nextFtp >= 75 && nextFtp < 100) {\n            return TR_RISE_SS;\n        }\n        if (curFtp < 100 && nextFtp >= 100) {\n            return TR_RISE_OVER_FTP;\n        }\n        if (curFtp >= 75 && nextFtp < 75) {\n            // check if the next interval is less than 1 minute\n            if (intervalData[curPosition+1].durationSecs <= 60) {\n                return TR_FALL_UNDER_75_LT_1M;\n            }\n            return TR_FALL_UNDER_75;\n        }\n        if (curFtp > 100 && nextFtp >= 75 && nextFtp < 100) {\n            return TR_FALL_SS;\n        }\n        return TR_STAY;\n    }\n}","import axios from 'axios';\n\nclass Spotify {\n    constructor(accessToken) {\n        this.accessToken = accessToken;\n    }\n\n    headers() {\n        return {\n            headers: {\n                \"Authorization\": \"Bearer \" + this.accessToken\n            }\n        };\n    }\n\n    async loadMyPlaylists() {\n        return axios.get(\"https://api.spotify.com/v1/me/playlists?limit=50\", this.headers());\n    }\n\n    async loadAllPlaylistTracks(playlistId) {\n        return axios.get(\"https://api.spotify.com/v1/playlists/\" + playlistId + \"/tracks\", this.headers());        \n    }\n\n    /**\n     * \n     * @param {Array} trackIds array\n     * @param {Function} trackDataCallback function\n     */\n    async loadAllTrackDetails(trackIds, trackDataCallback) {\n        while(trackIds.length > 0) {\n            let tracksToQuery = trackIds.splice(0, 50); // 50 is the cap for this API\n            let resp = await axios.get(\"https://api.spotify.com/v1/audio-features?ids=\"+encodeURIComponent(tracksToQuery.join(\",\")), this.headers())\n            trackDataCallback(resp.data);\n        }\n    }\n}\n\nexport default Spotify;","import React from 'react';\nimport { \n  Intervals, \n  StateMachine,\n  WARMING,\n  COOL,\n  SS_INTERVAL,\n  VO2_INTERVAL,\n  FINISH \n} from './Intervals.js';\nimport Spotify from './Spotify.js';\nimport moment from 'moment';\n\nclass GeneratePlaylist extends React.Component {\n    constructor(props) {\n      super(props);\n      this.stateMachine = new StateMachine();\n      this.getSongWithArtwork = this.getSongWithArtwork.bind(this);\n      this.playlistId = props.match.params.playlist_id;\n  \n      let ssBreak = {\n        ftpPercent: 45,\n        durationSecs: 4 * 60\n      };\n      let ssInterval = {\n        ftpPercent: 95,\n        durationSecs: 20 * 60\n      };\n      let vO2MaxInterval = {\n        ftpPercent: 120,\n        durationSecs: 7 * 60\n      };\n      let vO2MaxBreak = {\n        ftpPercent: 45,\n        durationSecs: 7 * 60\n      };\n      let anaerobicSprint = {\n        ftpPercent: 150,\n        durationSecs: 30\n      };\n      let anaerobicSprintRecovery = {\n        ftpPercent: 45,\n        durationSecs: 30\n      };\n      this.workouts = {\n        sweetSpot: {\n          name: \"3 x 20min Sweet Spot\",\n          intervalData: [\n            {\n              ftpPercent: 40,\n              durationSecs: 5 * 60\n            },\n            {\n              ftpPercent: 60,\n              durationSecs: 3 * 60\n            },\n            {\n              ftpPercent: 90,\n              durationSecs: 2 * 60\n            },\n            ssBreak,\n            ssInterval,\n            ssBreak,\n            ssInterval,\n            ssBreak,\n            ssInterval,\n            ssBreak\n          ]\n        },\n        vO2Max: {\n          name: \"6 x 7min vO2 Max\",\n          intervalData: [\n            {\n              ftpPercent: 40,\n              durationSecs: 5 * 60\n            },\n            {\n              ftpPercent: 60,\n              durationSecs: 3 * 60\n            },\n            {\n              ftpPercent: 95,\n              durationSecs: 2 * 60\n            },\n            {\n              ftpPercent: 45,\n              durationSecs: 5 * 60\n            },\n            vO2MaxInterval,\n            vO2MaxBreak,\n            vO2MaxInterval,\n            vO2MaxBreak,\n            vO2MaxInterval,\n            vO2MaxBreak,\n            vO2MaxInterval,\n            vO2MaxBreak,\n            vO2MaxInterval,\n            vO2MaxBreak,\n            vO2MaxInterval,\n            {\n              ftpPercent: 75,\n              durationSecs: 20 * 60\n            }\n          ]\n        },\n        sprints: {\n          name: \"6x3x1min Sprints\",\n          intervalData: [\n            {\n              ftpPercent: 40,\n              durationSecs: 5 * 60\n            },\n            {\n              ftpPercent: 60,\n              durationSecs: 3 * 60\n            },\n            {\n              ftpPercent: 95,\n              durationSecs: 2 * 60\n            },\n            {\n              ftpPercent: 45,\n              durationSecs: 5 * 60\n            },\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            {\n              ftpPercent: 45,\n              durationSecs: 5 * 60\n            },\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            {\n              ftpPercent: 45,\n              durationSecs: 5 * 60\n            },\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            anaerobicSprintRecovery,\n            anaerobicSprint,\n            {\n              ftpPercent: 45,\n              durationSecs: 5 * 60\n            }\n          ]\n        }\n      }\n      this.state = { playlistData: {}, songData: {}, selectedWorkout: this.workouts.sweetSpot };\n      this.spotify = new Spotify(localStorage.getItem(\"spotify_access_code\"));\n    }\n  \n    updateWorkout(workout) {\n      return () => {\n        if (this.state.selectedWorkout.name != workout.name) {\n          this.setState({ selectedWorkout: workout });\n        }\n      };\n    }\n  \n    componentDidMount() {\n        this.spotify.loadAllPlaylistTracks(this.playlistId).then((data) => {\n          this.updatePlaylistDataBase(data.data);\n          let trackIds = data.data.items.map((item) => (\n              item.track.id\n          ));\n          this.spotify.loadAllTrackDetails(trackIds, this.updateSongDataFeatures.bind(this));\n        });\n    }\n\n    updatePlaylistDataBase(data) {\n      let playlistDataObj = {}\n      data.items.forEach((item) => {\n        playlistDataObj[item.track.id] = item\n      });\n      this.setState({playlistData: playlistDataObj});\n    }\n\n    /**\n     * \n     * @param {Array} songData \n     */\n    updateSongDataFeatures(songData) {\n      let songDataObj = this.state.songData;\n      songData.audio_features.map((item) => {\n        if (item) {\n          songDataObj[item.id] = item;\n        }\n      })\n      this.setState({songData:  songDataObj});\n    }\n  \n    render() {\n      let songs = Object.keys(this.state.playlistData).map((itemKey) => {\n        let item = this.state.playlistData[itemKey];\n\n        var trackData = {\n          \"danceability\": \"\",\n          \"energy\":\"\",\n          \"key\":6,\n          \"loudness\":-4.19,\n          \"mode\":0,\n          \"speechiness\":0.392,\n          \"acousticness\":0.326,\n          \"instrumentalness\":0.00443,\n          \"liveness\":0.0516,\n          \"valence\":\"\",\n          \"tempo\":\"\",\n          \"type\":\"audio_features\",\n          \"id\":\"0AcDvwLwqh72opYiqkfJ14\",\n          \"uri\":\"spotify:track:0AcDvwLwqh72opYiqkfJ14\",\n          \"track_href\":\"https://api.spotify.com/v1/tracks/0AcDvwLwqh72opYiqkfJ14\",\n          \"analysis_url\":\"https://api.spotify.com/v1/audio-analysis/0AcDvwLwqh72opYiqkfJ14\",\n          \"duration_ms\":219333,\n          \"time_signature\":4\n        };\n        if (this.state.songData[itemKey]) {\n          trackData = this.state.songData[itemKey];\n        }\n\n        return <tr key={item.track.id}>\n          <td>{item.track.name}</td>\n          <td>{item.track.artists[0].name}</td>\n          <td>{moment.duration(item.track.duration_ms).humanize()}</td>\n          <td>{trackData.danceability}</td>\n          <td>{trackData.energy}</td>\n          <td>{trackData.loudness}</td>\n          <td>{trackData.valence}</td>\n          <td>{trackData.tempo}</td>\n        </tr>\n      });\n\n      let playlist = this.computePlaylist();\n\n      let intensities = playlist.map((intensity, i) => (\n        <tr key={\"intensity-\" + i}>\n          <td>{intensity.intensity.state} for {moment.duration(intensity.intensity.durationSecs, \"seconds\").humanize()}</td>\n          <td>\n            {intensity.songs.map(song => \n              <span key={\"intensity-\" + i + \"-song-\" + song.id}><img src={song.artwork} title={song.name}/></span>\n            )}\n          </td>\n          <td>\n            {moment.duration(intensity.songs.map(song => song.durationMs).reduce((a,b)=> a+b), \"milliseconds\").humanize()}\n          </td>\n        </tr> \n      ));\n\n\n      return <div>\n        <form>\n          <label><input type=\"radio\" name=\"workout\" value=\"Sweet Spot\" onChange={this.updateWorkout(this.workouts.sweetSpot)} /> Sweet Spot</label>\n          <label><input type=\"radio\" name=\"workout\" value=\"VO2 Max\" onChange={this.updateWorkout(this.workouts.vO2Max)} /> vO2 Max</label>\n          <label><input type=\"radio\" name=\"workout\" value=\"Sprints\" onChange={this.updateWorkout(this.workouts.sprints)} /> Sprints</label>\n          <label><input type=\"radio\" name=\"workout\" value=\"Custom\" disabled /> Custom</label>\n        </form>\n        <Intervals \n          data={this.state.selectedWorkout} \n          size={[window.innerWidth*.99, 300]}\n          playlistData={playlist}></Intervals>\n        <div className=\"playlist-display\">\n          <table>\n            <tbody>{intensities}</tbody>\n          </table>\n        </div>\n        <hr></hr>\n        <table>\n          <thead>\n            <tr>\n              <th>Title</th>\n              <th>Artist</th>\n              <th>Duration</th>\n              <th>Danceability</th>\n              <th>Energy</th>\n              <th>Loudness</th>\n              <th>Valence</th>\n              <th>Tempo</th>\n            </tr>\n          </thead>\n          <tbody>{songs}</tbody>\n          </table>\n      </div>\n    }\n\n    computePlaylist() {\n      // check if there are at least 75 songs with song data\n      // basic implementation:\n      // maintain a state machine for the intervals \n      \n      // iterate through all intervals\n      // -- find 1 or more songs that match the intensity and have a duration between (interval, interval+cooldown]\n      // -- fill gap of remaining cooldown time with meditative songs\n      // -- add a short celebration at the end :) \n      \n      let intensities = this.stateMachine.computeIntervalIntensities(this.state.selectedWorkout.intervalData);\n      \n      if (Object.keys(this.state.playlistData).length - Object.keys(this.state.songData).length > 10) {\n        // we are missing song data for a decent chunk of songs, don't continue;\n        return [];\n      }\n\n      let songs = {\n        WARMING: this.getWarmupSongs(),\n        SS_INTERVAL: this.getSSSongs(),\n        VO2_INTERVAL: this.getVO2MaxSongs()\n      };\n\n      for (let song of this.getWarmupSongs()) {\n        console.log(song.id + \"\\t\" + song.duration_ms);\n      }\n\n      let oneMin = [];\n      let twoMin = [];\n      let thirtySec = [];\n      let ninetySec = [];\n\n      twoMin.push(\"60JoeD2lqbdEdHJKWpr4fR\");\n      oneMin.push(\"7gwRSZ0EmGWa697ZrE58GA\");\n      oneMin.push(\"2JlC2hgOEYEUAUzZEEMPgA\");\n      twoMin.push(\"4CECHdtCQxRw0RNnuBe38V\");\n      ninetySec.push(\"0ctfhLgKb9qQIHlN3Gebmt\");\n      thirtySec.push(\"6ycpWuXW7hxgsT0cRcCFJX\");\n      thirtySec.push(\"6BZR3QtpAX74TNGvjBw0ce\");\n      oneMin.push(\"1dgTolpKW9lnFpDuX0hSaS\");\n      oneMin.push(\"46bub9IoIo1gbmvLKdvSzG\");\n      oneMin.push(\"6ceKf0vFlAS9yvvoC4l2zq\");\n      oneMin.push(\"0SMxJhM52yVnA7H1oEY6e7\");\n      oneMin.push(\"0SMKzTJ7OQdIADSyWN6l62\");\n      oneMin.push(\"0Z1hc8dk4gvPRv9cskhtKX\");\n      thirtySec.push(\"2f0g5LMi7DMcFxhUSlKbDc\");\n      oneMin.push(\"0juXJUnKNGLiJCqPO1sY2a\");\n      oneMin.push(\"0ziDFYykduFnaDJY0l0Eew\");\n\n      let playlist = [];\n\n      // try not to reuse songs\n      let usedSongs = {};\n      let previousIntensityRemainderMs = 0;\n      for (let i = 0; i < intensities.length; i++) {\n        // get intensity, pop song from respective list, while its already in use\n        \n        let selectedIntensitySongs = [];\n        \n        let candidateSongs = songs[intensities[i].state];\n        let highIntensitySetMs = intensities[i].durationSecs * 1000;\n        let durationRemainingMs = highIntensitySetMs + previousIntensityRemainderMs;\n        \n        // include the next interval too if it's considered a cooldown\n        if (i < intensities.length-1 && !songs[intensities[i+1].state]) {\n          durationRemainingMs += intensities[i+1].durationSecs * 1000;\n        }\n        // if this is an intensity we have songs for (ie, not a cooldown), proceed to add songs.\n        if (candidateSongs) {\n          // loop until we have consumed as much of the duration without going over our limit.        \n          let keepGoing = true;\n          while (keepGoing) {\n            let inUse = true;\n            let songCandidate = null;\n            while (inUse) { // while a song is in use, get the next one\n              if (candidateSongs.length == 0) {\n                break;\n              }\n              songCandidate = candidateSongs.pop();\n              inUse = usedSongs[songCandidate.id];\n            }\n            if (!songCandidate) {\n              keepGoing = false;\n              break;\n            }\n            if (songCandidate.duration_ms <= durationRemainingMs) {\n              usedSongs[songCandidate.id] = true;\n              selectedIntensitySongs.push(songCandidate);\n              durationRemainingMs = durationRemainingMs - songCandidate.duration_ms;\n            } else {\n              // - if there are no songs for the intensity yet, keep popping until we find one or we're out\n              // - if there is at least one, bail when we hit a song that goes over the limit\n              if (selectedIntensitySongs.length > 0) {\n                keepGoing = false;\n              }\n            }\n          }\n          // To fill the gap between intensitiies, we have a set of pre-determined 30, 60, 2m and 4m tracks that\n          // are lower intensity and make the transition back into intense intervals more exciting. Also removes\n          // the general packing problem issues.\n          let remainder = durationRemainingMs % 30;\n          let decompressionTime = durationRemainingMs - remainder;\n          selectedIntensitySongs.push({\n            id: \"decompression\",\n            durationMs: decompressionTime\n          })\n          previousIntensityRemainderMs = remainder;\n          playlist.push({\n            intensity: intensities[i],\n            songs: selectedIntensitySongs.map(this.getSongWithArtwork)\n          });\n        }\n      }\n      return playlist\n    };\n\n    getSongWithArtwork(song) {\n      if (song.id == 'decompression') {\n        return song\n      }\n      var artwork = null;\n      let playlistSongInfo = this.state.playlistData[song.id].track;\n\n      if (playlistSongInfo.album && playlistSongInfo.album.images) {\n        for (let i = 0; i < playlistSongInfo.album.images.length; i++) {\n          let albumImages = playlistSongInfo.album.images[i];\n          if (albumImages.height <= 64) {\n            artwork = albumImages.url;\n            break;\n          }\n        }\n      }\n\n      var artist = null;\n      if (playlistSongInfo.artists && playlistSongInfo.artists.length > 0) {\n        artist = playlistSongInfo.artists[0].name;\n      }\n\n      return {\n        id: song.id,\n        durationMs: song.duration_ms,\n        artwork: artwork,\n        name: playlistSongInfo.name,\n        artist: artist\n      };\n    }\n\n    songFeaturesAsArray() {\n      return Object.keys(this.state.songData).map((key) => this.state.songData[key]);\n    }\n\n    getWarmupSongs() {\n      // get all songs, sort by danceability\n      let songs = this.songFeaturesAsArray();\n      songs.sort((song1, song2) => {\n        return song2.danceability - song1.danceability;\n      });\n      return songs;\n    }\n\n    getSSSongs() {\n      // get all songs, sort by length\n      let songs = this.songFeaturesAsArray();\n      songs.sort((song1, song2) => {\n        return song2.duration_ms - song1.duration_ms;\n      });\n      return songs;\n    }\n\n    getVO2MaxSongs() {\n      // get all songs, sort by tempo (BPM)\n      let songs = this.songFeaturesAsArray();\n      songs.sort((song1, song2) => {\n        return song2.tempo - song1.tempo;\n      });\n      return songs;\n    }\n  }\n\n  export default GeneratePlaylist;","import React from 'react';\nimport GeneratePlaylist from './GeneratePlaylist.js';\nimport './App.css';\nimport axios from 'axios';\nimport Spotify from './Spotify';\nimport querystring from 'querystring';\n\nimport { BrowserRouter, Route, Link, Redirect } from \"react-router-dom\";\n\nconst SPOTIFY_CLIENT_ID = 'ca1d41a2da864fd6812b292fedd8adb8';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <div className=\"App\">\n        <Route path=\"/\" exact component={SpotifyComponent}></Route>\n        <Route path=\"/spotify/callback\" component={SpotifyExchangeCodeForAccessToken}></Route>\n        <Route path=\"/generate/:playlist_id\" component={GeneratePlaylist}></Route>\n      </div>\n    </BrowserRouter>\n  );\n}\n\nclass SpotifyComponent extends React.Component {\n\n  constructor(props) {\n    super(props);\n    this.handleLoginClick = this.handleLoginClick.bind(this);\n    this.spotifyAccessCode = localStorage.getItem(\"spotify_access_code\");\n    this.state = { playlists: [], spotifyError: null };\n  }\n\n  handleLoginClick() {\n    var scopes = \"user-read-email playlist-read-collaborative playlist-read-private\";\n    var url = 'https://accounts.spotify.com/authorize' +\n      '?response_type=token' +\n      '&client_id=' + SPOTIFY_CLIENT_ID + '&scope=' + encodeURIComponent(scopes) +\n      '&redirect_uri=' + encodeURIComponent('http://localhost:3000/spotify/callback');\n    window.location.href = url;\n  }\n\n  render() {\n    var spotifyBody;\n    if (this.spotifyAccessCode) {\n      var listItems = this.state.playlists.map(playlist => (\n        <div key={playlist.id}>\n          <Link to={{ pathname: \"/generate/\" + playlist.id }} className=\"App-link\"> {playlist.name} ({playlist.tracks.total} Tracks)</Link>\n        </div>\n      ));\n      var spotifyError;\n      if (this.state.spotifyError) {\n        spotifyError = <div class=\"error\">{this.state.spotifyError}</div>;\n      } else {\n        spotifyError = <div></div>;\n      }\n\n      spotifyBody = <div>\n        <h4>Select a playlist to use as your source</h4>\n        {spotifyError}\n        <ul >{listItems}</ul>\n      </div>\n    } else {\n      spotifyBody = <div><a href=\"#\" onClick={this.handleLoginClick}>Log in to Spotify</a></div>\n    }\n\n    return <div>\n      <h3>Spotify Interval Playlist Generator</h3>\n      {spotifyBody}\n    </div>\n  }\n\n  componentDidMount() {\n    if (this.spotifyAccessCode) {\n      var self = this;\n      \n      new Spotify(this.spotifyAccessCode).loadMyPlaylists().then(resp => {\n        self.setState({ playlists: resp.data.items });\n      }).catch(error => {\n        console.log(error);\n        self.setState({ spotifyError: \"Could not load playlists: \" + error });\n      });\n    }\n  }\n}\n\n\nclass SpotifyExchangeCodeForAccessToken extends React.Component {\n  render() {\n    return <div>Loading...</div>;\n  }\n  componentDidMount() {\n    let query = new URLSearchParams(this.props.location.search);\n    \n    var accessToken = null;\n    var split = this.props.location.hash.split(\"&\");\n    for (let hashComp of split) {\n      if (hashComp.includes(\"#access_token=\")) {\n        accessToken = hashComp.replace(\"#access_token=\", \"\");\n        break;\n      }\n    }\n    localStorage.setItem('spotify_access_code', accessToken)\n    this.props.history.push('/');\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}